<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Título actualizado -->
    <title>Demo MOBA 2.5D con Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", sans-serif;
            background-color: #111;
            color: white;
        }
        #info-bar {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* z-index más alto para estar sobre el canvas */
            z-index: 10;
        }
        /* Estilo para el canvas */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* z-index más bajo para estar detrás de la info */
            z-index: 1;
            /* Color de fondo por si acaso */
            background-color: #333;
        }
    </style>
</head>
<body>

    <div id="info-bar">
        Conectando a Firebase...
        <br>
        <strong>Instrucciones:</strong> ¡Haz clic en el mapa para moverte!
    </div>

    <!-- Canvas 2D en lugar de que Three.js cree uno -->
    <canvas id="game-canvas"></canvas>

    <script type="module">
        // 1. Importar las funciones necesarias del SDK de Firebase
        // (Esto no cambia)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getDatabase, ref, set, onValue, onDisconnect, update } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        // 2. Configuración de Firebase (proporcionada por el usuario)
        // (Esto no cambia)
        const firebaseConfig = {
          apiKey: "AIzaSyAfK_AOq-Pc2bzgXEzIEZ1ESWvnhMJUvwI",
          authDomain: "enraya-51670.firebaseapp.com",
          // --- ¡CORRECCIÓN AQUÍ! ---
          // Cambiado de firebasede.app a firebasedatabase.app
          databaseURL: "https://enraya-51670-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "enraya-51670",
          storageBucket: "enraya-51670.firebasestorage.app",
          messagingSenderId: "103343380727",
          appId: "1:103343380727:web:b2fa02aee03c9506915bf2",
          measurementId: "G-2G31LLJY1T"
        };

        // 3. Variables globales del juego y Firebase
        let app;
        let auth;
        let db;
        let myPlayerId;
        let playersRef;
        let playersState = {}; // Estado objetivo desde Firebase (a dónde ir)
        let interpolatedPlayersState = {}; // Estado local renderizado (dónde está ahora)
        
        const MOVEMENT_SPEED = 0.05; // Velocidad de interpolación (igual que antes)

        // Variables de Canvas 2D
        let canvas, ctx;
        let infoBar;
        
        // Variables de la cámara 2.5D
        // Este offset es el "scroll" de la cámara
        let cameraOffset = { x: 0, y: 0 }; 
        // Constantes de la proyección isométrica (definen el "look" 2.5D)
        const ISO_TILE_W_HALF = 32; // Ancho de un "tile" a la mitad
        const ISO_TILE_H_HALF = 16; // Alto de un "tile" a la mitad

        // Variables del jugador
        const playerSize = 1.0; // Tamaño lógico (usado para la altura)
        const playerImg = new Image();
        let playerImgLoaded = false;
        const playerImgWidth = 48; // Ancho de la imagen en píxeles
        const playerImgHeight = 48; // Alto de la imagen en píxeles
        const playerTextureURL = 'https://www.nicepng.com/png/detail/218-2183282_dnd-warrior-png-human-fighter-dual-wield.png';

        // 4. Función principal que se ejecuta al cargar la página
        window.onload = () => {
            infoBar = document.getElementById('info-bar');

            // Inicializar Canvas
            initCanvas();

            // Configurar el tamaño del canvas
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Cargar la imagen del jugador
            playerImg.onload = () => {
                playerImgLoaded = true;
            };
            playerImg.onerror = () => {
                console.error("No se pudo cargar la textura del jugador.");
            }
            playerImg.crossOrigin = "anonymous"; // Necesario para cargar desde Firebase Storage
            playerImg.src = playerTextureURL;

            // Iniciar Firebase
            initializeFirebase();
        };

        // 5. Ajustar el tamaño del canvas
        function resizeCanvas() {
            if (canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }

        // 5.5. Inicializar el canvas 2D
        function initCanvas() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Centrar la cámara inicialmente
            cameraOffset.x = canvas.width / 2;
            cameraOffset.y = canvas.height / 4; // Empezar un poco más arriba

            // Configurar el clic para mover
            setupClickMove2_5D();
        }

        // 6. Inicializar Firebase y autenticación (Idéntico a antes)
        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getDatabase(app);
                
                playersRef = ref(db, 'moba-demo-players-3d'); // Usamos el mismo nodo

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        myPlayerId = user.uid;
                        infoBar.innerHTML = `Conectado. <br> <strong>Tu UserID:</strong> ${myPlayerId.substring(0, 6)}<br><strong>Instrucciones:</strong> Haz clic para moverte.`;
                        setupGame(myPlayerId);
                    } else {
                        signInAnonymously(auth).catch((error) => {
                            console.error("Error al iniciar sesión anónimamente:", error);
                            infoBar.textContent = "Error al conectar con Firebase Auth.";
                        });
                    }
                });

            } catch (error) {
                console.error("Error al inicializar Firebase:", error);
                infoBar.textContent = "Error al inicializar Firebase. Revisa la consola.";
            }
        }

        // 7. Configurar el jugador en la base de datos (Idéntico a antes)
        function setupGame(playerId) {
            const myPlayerRef = ref(db, `moba-demo-players-3d/${playerId}`);
            
            const randomX = (Math.random() * 40) - 20;
            const randomZ = (Math.random() * 40) - 20;
            
            const initialData = {
                id: playerId,
                x: randomX,
                z: randomZ,
                // 'y' (altura) no se guarda, la asumimos constante
            };

            set(myPlayerRef, initialData);
            onDisconnect(myPlayerRef).remove();

            listenForPlayers();
            gameLoop(); // Iniciar el bucle de renderizado de Canvas
        }

        // 8. Escuchar todos los cambios en el nodo 'players'
        function listenForPlayers() {
            onValue(playersRef, (snapshot) => {
                playersState = snapshot.val() || {};

                // Sincronizar el estado interpolado con el estado de Firebase
                // Añadir nuevos jugadores
                for (const id in playersState) {
                    if (!interpolatedPlayersState[id]) {
                        // Nuevo jugador: copiar datos
                        interpolatedPlayersState[id] = { ...playersState[id] };
                    }
                }

                // Eliminar jugadores desconectados
                for (const id in interpolatedPlayersState) {
                    if (!playersState[id]) {
                        delete interpolatedPlayersState[id];
                    }
                }
            });
        }

        // --- INICIO DE NUEVAS FUNCIONES DE RENDERIZADO 2.5D ---

        /**
         * Proyecta coordenadas del mundo 3D (x, y, z) a coordenadas de pantalla 2D (x, y).
         * @param {number} worldX - Coordenada X del mundo (horizontal)
         * @param {number} worldY - Coordenada Y del mundo (altura)
         * @param {number} worldZ - Coordenada Z del mundo (profundidad)
         * @returns {{x: number, y: number}} - Coordenadas de pantalla
         */
        function project(worldX, worldY, worldZ) {
            const screenX = cameraOffset.x + (worldX - worldZ) * ISO_TILE_W_HALF;
            const screenY = cameraOffset.y + (worldX + worldZ) * ISO_TILE_H_HALF - worldY;
            return { x: screenX, y: screenY };
        }

        /**
         * Convierte coordenadas de pantalla 2D (clic) a coordenadas del plano del suelo 3D (x, z).
         * Esta es la "inversa" de la función project (asumiendo worldY = 0).
         * @param {number} screenX - Coordenada X de la pantalla
         * @param {number} screenY - Coordenada Y de la pantalla
         * @returns {{x: number, z: number}} - Coordenadas del mundo (en el suelo)
         */
        function inverseProject(screenX, screenY) {
            // Ajustar por el offset de la cámara (asumiendo y=0)
            const screenXFromOrigin = screenX - cameraOffset.x;
            const screenYFromOrigin = screenY - cameraOffset.y;
            
            // Ecuaciones de la inversa (derivadas algebraicamente)
            const worldX = (screenXFromOrigin / ISO_TILE_W_HALF + screenYFromOrigin / ISO_TILE_H_HALF) / 2;
            const worldZ = (screenYFromOrigin / ISO_TILE_H_HALF - screenXFromOrigin / ISO_TILE_W_HALF) / 2;
            
            return { x: worldX, z: worldZ };
        }


        // 9. Configurar el listener de clic para mover al jugador en 2.5D
        function setupClickMove2_5D() {
            window.addEventListener('click', (event) => {
                if (!myPlayerId || !ctx) return;
                
                // No queremos movernos si hacemos clic en la barra de info
                if (event.target !== canvas) return;

                const screenX = event.clientX;
                const screenY = event.clientY;

                // Convertir clic de pantalla a coordenadas del mundo
                const worldCoords = inverseProject(screenX, screenY);

                // Actualizar la posición de nuestro jugador en Firebase
                const myPlayerRef = ref(db, `moba-demo-players-3d/${myPlayerId}`);
                update(myPlayerRef, {
                    x: worldCoords.x,
                    z: worldCoords.z
                });
            });
        }

        // 10. Bucle principal del juego (renderiza en el canvas)
        function gameLoop() {
            requestAnimationFrame(gameLoop); // Llamar primero para un bucle más suave

            if (!ctx) return; // Salir si el canvas no está listo

            // Actualizar la cámara para que siga al jugador
            updateCameraPosition();
            
            // Interpolar las posiciones de todos los jugadores
            updatePlayerPositions();

            // Limpiar el canvas
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Dibujar el suelo
            drawGroundGrid();

            // Dibujar a los jugadores
            renderPlayers();
        }

        // 10.5. Función para interpolar posiciones
        function updatePlayerPositions() {
            for (const id in playersState) {
                const targetPlayerData = playersState[id]; // Datos de Firebase (destino)
                const playerMesh = interpolatedPlayersState[id]; // Datos locales (actual)

                if (!playerMesh) continue; 

                const targetX = targetPlayerData.x;
                const targetZ = targetPlayerData.z;

                // --- Lógica de Interpolación (Lerp) --- (Idéntica a antes)
                const dx = targetX - playerMesh.x;
                const dz = targetZ - playerMesh.z;
                
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < MOVEMENT_SPEED) {
                    playerMesh.x = targetX;
                    playerMesh.z = targetZ;
                } else {
                    const normX = dx / distance;
                    const normZ = dz / distance;
                    playerMesh.x += normX * MOVEMENT_SPEED;
                    playerMesh.z += normZ * MOVEMENT_SPEED;
                }
            }
        }

        /**
         * Dibuja una rejilla isométrica en el suelo
         */
        function drawGroundGrid() {
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5; // Hacer la rejilla semitransparente

            const gridSize = 20;
            for (let i = -gridSize; i <= gridSize; i++) {
                // Dibujar líneas en la dirección X
                let p1 = project(i, 0, -gridSize);
                let p2 = project(i, 0, gridSize);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                // Dibujar líneas en la dirección Z
                let p3 = project(-gridSize, 0, i);
                let p4 = project(gridSize, 0, i);
                ctx.beginPath();
                ctx.moveTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0; // Restaurar alfa
        }


        /**
         * Dibuja todos los jugadores en el canvas
         */
        function renderPlayers() {
            if (!playerImgLoaded) return; // No dibujar si la imagen no ha cargado

            // Convertir el objeto a un array para poder ordenarlo
            const playersToRender = Object.values(interpolatedPlayersState);

            // Ordenar jugadores por "profundidad" (sorting)
            // Los jugadores con (x + z) más pequeño están "más lejos" y se dibujan primero.
            playersToRender.sort((a, b) => {
                return (a.x + a.z) - (b.x + b.z);
            });

            // Dibujar cada jugador
            for (const player of playersToRender) {
                // Asumimos que la altura del jugador (pies) es playerSize
                const playerHeight = playerSize; 
                const screenPos = project(player.x, playerHeight, player.z);

                // Dibujar la imagen del jugador
                // (screenPos.x - ancho/2) -> centrar la imagen horizontalmente
                // (screenPos.y - alto) -> poner los "pies" de la imagen en el punto proyectado
                ctx.drawImage(
                    playerImg,
                    screenPos.x - playerImgWidth / 2,
                    screenPos.y - playerImgHeight,
                    playerImgWidth,
                    playerImgHeight
                );

                // Dibujar el nombre/ID
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '12px Inter';
                ctx.fillText(
                    player.id.substring(0, 6), 
                    screenPos.x, 
                    screenPos.y - playerImgHeight - 5 // 5px encima de la imagen
                );
            }
        }


        // 10.6. Función para actualizar la posición de la cámara
        function updateCameraPosition() {
            if (!myPlayerId || !interpolatedPlayersState[myPlayerId] || !canvas) {
                return; 
            }

            const myPlayer = interpolatedPlayersState[myPlayerId];
            const playerHeight = playerSize; // La misma altura usada en el render

            // Queremos que el jugador esté en el centro de la pantalla
            // Usamos la fórmula de proyección para calcular el offset necesario
            
            const targetScreenX = canvas.width / 2;
            const targetScreenY = canvas.height / 2;

            // Calculamos dónde estaría el jugador SIN offset
            const playerScreenXWithoutOffset = (myPlayer.x - myPlayer.z) * ISO_TILE_W_HALF;
            const playerScreenYWithoutOffset = (myPlayer.x + myPlayer.z) * ISO_TILE_H_HALF - playerHeight;

            // El offset es la diferencia entre dónde queremos que esté y dónde estaría
            cameraOffset.x = targetScreenX - playerScreenXWithoutOffset;
            cameraOffset.y = targetScreenY - playerScreenYWithoutOffset;
        }

    </script>
</body>
</html>

